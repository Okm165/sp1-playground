#![allow(
    clippy::eq_op,
    clippy::new_without_default,
    clippy::field_reassign_with_default,
    clippy::unnecessary_cast,
    clippy::cast_abs_to_unsigned,
    clippy::needless_range_loop,
    clippy::type_complexity,
    clippy::unnecessary_unwrap,
    clippy::default_constructed_unit_structs,
    clippy::box_default
)]

extern crate alloc;

pub mod air;
pub mod alu;
pub mod bytes;
pub mod chip;
pub mod cpu;
pub mod disassembler;
pub mod field;
pub mod lookup;
pub mod memory;
pub mod operations;
pub mod program;
pub mod runtime;
pub mod stark;
pub mod syscall;
pub mod utils;

use rand::{rngs::StdRng, SeedableRng};
use runtime::{Program, Runtime};
use serde::{de::DeserializeOwned, Serialize};
use stark::{ProgramVerificationError, Proof};
use utils::{prove_core, BabyBearBlake3, StarkUtils};

/// A prover that can prove RISCV ELFs.
pub struct SuccinctProver {
    stdin: Vec<u8>,
    stdout: Vec<u8>,
    stdout_ptr: usize,
}

/// A verifier that can verify proofs generated by `SuccinctProver`.
pub struct SuccinctVerifier;

/// A proof of a RISCV ELF execution with given inputs and outputs.
pub struct SuccinctProof {
    pub proof: Proof<BabyBearBlake3>,
    pub stdin: Vec<u8>,
    pub stdin_ptr: usize,
    pub stdout: Vec<u8>,
    pub stdout_ptr: usize,
}

impl SuccinctProver {
    /// Create a new prover instance.
    pub fn new() -> Self {
        Self {
            stdin: Vec::new(),
            stdout: Vec::new(),
            stdout_ptr: 0,
        }
    }

    /// Write to the public input stream.
    pub fn write_stdin<T: Serialize>(&mut self, input: &T) {
        let mut buf = Vec::new();
        bincode::serialize_into(&mut buf, input).expect("serialization failed");
        self.stdin.extend(buf);
    }

    /// Read from the public output stream.
    pub fn read_stdout<T: Serialize + DeserializeOwned>(&mut self) -> T {
        let result: T = bincode::deserialize(&self.stdout[self.stdout_ptr..]).unwrap();
        let nb_bytes = bincode::serialized_size(&result).unwrap();
        self.stdout_ptr += nb_bytes as usize;
        result
    }

    /// Execute the ELF with the given public inputs.
    ///
    /// Note that this function does not generate a proof.
    pub fn run(&self, elf: &[u8]) -> Runtime {
        let program = Program::from(elf);
        let mut runtime = Runtime::new(program);
        runtime.write_stdin_slice(&self.stdin);
        runtime.run();
        runtime
    }

    /// Generate a proof for the execution of the ELF with the given public inputs.
    pub fn prove(&self, elf: &[u8]) -> SuccinctProof {
        let mut runtime = self.run(elf);
        let proof = prove_core(&mut runtime);
        SuccinctProof {
            proof,
            stdin: runtime.state.input_stream,
            stdin_ptr: 0,
            stdout: runtime.state.output_stream,
            stdout_ptr: 0,
        }
    }

    /// Reset the prover to a default state.
    pub fn reset(&mut self) {
        self.stdin = Vec::new();
        self.stdout = Vec::new();
    }
}

impl SuccinctVerifier {
    /// Create a new verifier instance.
    pub fn new() -> Self {
        Self {}
    }

    /// Verify a proof generated by `SuccinctProver`.
    #[allow(unused_variables)]
    pub fn verify(
        &self,
        elf: &[u8],
        proof: &SuccinctProof,
    ) -> Result<(), ProgramVerificationError> {
        let mut rng: StdRng = SeedableRng::from_seed([17; 32]);
        let config = BabyBearBlake3::new(&mut rng);
        let mut challenger = config.challenger();
        Runtime::verify(&config, &mut challenger, &proof.proof)
    }
}

impl SuccinctProof {
    /// Read from the public output stream.
    pub fn read_stdout<T: Serialize + DeserializeOwned>(&mut self) -> T {
        let result: T = bincode::deserialize(&self.stdout[self.stdout_ptr..]).unwrap();
        let nb_bytes = bincode::serialized_size(&result).unwrap();
        self.stdout_ptr += nb_bytes as usize;
        result
    }
}

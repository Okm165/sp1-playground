#![allow(
    clippy::eq_op,
    clippy::new_without_default,
    clippy::field_reassign_with_default,
    clippy::unnecessary_cast,
    clippy::cast_abs_to_unsigned,
    clippy::needless_range_loop,
    clippy::type_complexity,
    clippy::unnecessary_unwrap,
    clippy::default_constructed_unit_structs,
    clippy::box_default
)]

extern crate alloc;

pub mod air;
pub mod alu;
pub mod bytes;
pub mod cpu;
pub mod disassembler;
pub mod field;
pub mod io;
pub mod lookup;
pub mod memory;
pub mod operations;
pub mod program;
pub mod runtime;
pub mod stark;
pub mod syscall;
pub mod utils;

pub use io::*;

use anyhow::Result;
use p3_commit::Pcs;
use p3_matrix::dense::RowMajorMatrix;
use runtime::{Program, Runtime};
use serde::de::DeserializeOwned;
use serde::Serialize;
use stark::{OpeningProof, ProgramVerificationError, Proof, ShardMainData};
use stark::{RiscvStark, StarkGenericConfig};
use std::fs;
use utils::{prove_core, BabyBearBlake3, StarkUtils};

/// A prover that can prove RISCV ELFs.
pub struct CurtaProver;

/// A verifier that can verify proofs generated by `CurtaProver`.
pub struct CurtaVerifier;

/// A proof of a RISCV ELF execution with given inputs and outputs.
#[derive(Serialize)]
pub struct CurtaProofWithIO<SC: StarkGenericConfig + Serialize> {
    #[serde(serialize_with = "serialize_proof")]
    pub proof: Proof<SC>,
    pub stdin: CurtaStdin,
    pub stdout: CurtaStdout,
}

impl CurtaProver {
    /// Executes the elf with the given inputs and returns the output.
    pub fn execute(elf: &[u8], stdin: CurtaStdin) -> Result<CurtaStdout> {
        let program = Program::from(elf);
        let mut runtime = Runtime::new(program);
        runtime.write_stdin_slice(&stdin.buffer.data);
        runtime.run();
        Ok(CurtaStdout::from(&runtime.state.output_stream))
    }

    /// Generate a proof for the execution of the ELF with the given public inputs.
    pub fn prove(elf: &[u8], stdin: CurtaStdin) -> Result<CurtaProofWithIO<BabyBearBlake3>> {
        let program = Program::from(elf);
        let mut runtime = Runtime::new(program);
        runtime.write_stdin_slice(&stdin.buffer.data);
        tracing::info_span!("runtime.run(...)").in_scope(|| {
            runtime.run();
        });
        let config = BabyBearBlake3::new();
        let proof = prove_core(config, &mut runtime);
        Ok(CurtaProofWithIO {
            proof,
            stdin,
            stdout: CurtaStdout::from(&runtime.state.output_stream),
        })
    }

    /// Generate a proof for the execution of the ELF with the given public inputs and a custom config.
    pub fn prove_with_config<SC: StarkGenericConfig>(
        elf: &[u8],
        stdin: CurtaStdin,
        config: SC,
    ) -> Result<CurtaProofWithIO<SC>>
    where
        SC: StarkUtils + Send + Sync + Serialize + Clone,
        SC::Challenger: Clone,
        OpeningProof<SC>: Send + Sync,
        <SC::Pcs as Pcs<SC::Val, RowMajorMatrix<SC::Val>>>::Commitment: Send + Sync,
        <SC::Pcs as Pcs<SC::Val, RowMajorMatrix<SC::Val>>>::ProverData: Send + Sync,
        ShardMainData<SC>: Serialize + DeserializeOwned,
        <SC as StarkGenericConfig>::Val: p3_field::PrimeField32,
    {
        let program = Program::from(elf);
        let mut runtime = Runtime::new(program);
        runtime.write_stdin_slice(&stdin.buffer.data);
        runtime.run();
        let proof = prove_core(config, &mut runtime);
        Ok(CurtaProofWithIO {
            proof,
            stdin,
            stdout: CurtaStdout::from(&runtime.state.output_stream),
        })
    }
}

impl CurtaVerifier {
    /// Verify a proof generated by `CurtaProver`.
    #[allow(unused_variables)]
    pub fn verify(
        elf: &[u8],
        proof: &CurtaProofWithIO<BabyBearBlake3>,
    ) -> Result<(), ProgramVerificationError> {
        let config = BabyBearBlake3::new();
        let mut challenger = config.challenger();
        let machine = RiscvStark::new(config);
        let (_, vk) = machine.setup(&Program::from(elf));
        machine.verify(&vk, &proof.proof, &mut challenger)
    }

    /// Verify a proof generated by `CurtaProver` with a custom config.
    #[allow(unused_variables)]
    pub fn verify_with_config<SC: StarkGenericConfig>(
        elf: &[u8],
        proof: &CurtaProofWithIO<SC>,
        config: SC,
    ) -> Result<(), ProgramVerificationError>
    where
        SC: StarkUtils + Send + Sync + Serialize,
        SC::Challenger: Clone,
        OpeningProof<SC>: Send + Sync,
        <SC::Pcs as Pcs<SC::Val, RowMajorMatrix<SC::Val>>>::Commitment: Send + Sync,
        <SC::Pcs as Pcs<SC::Val, RowMajorMatrix<SC::Val>>>::ProverData: Send + Sync,
        ShardMainData<SC>: Serialize + DeserializeOwned,
        <SC as StarkGenericConfig>::Val: p3_field::PrimeField32,
    {
        let mut challenger = config.challenger();
        let machine = RiscvStark::new(config);

        let (_, vk) = machine.setup(&Program::from(elf));
        machine.verify(&vk, &proof.proof, &mut challenger)
    }
}

impl<SC: StarkGenericConfig + Serialize> CurtaProofWithIO<SC> {
    /// Saves the proof as a JSON to the given path.
    pub fn save(&self, path: &str) -> Result<()> {
        let data = serde_json::to_string(self).unwrap();
        fs::write(path, data).unwrap();
        Ok(())
    }
}
